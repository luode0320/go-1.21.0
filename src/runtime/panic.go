// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime

import (
	"internal/abi"
	"internal/goarch"
	"runtime/internal/atomic"
	"runtime/internal/sys"
	"unsafe"
)

// throwType indicates the current type of ongoing throw, which affects the
// amount of detail printed to stderr. Higher values include more detail.
type throwType uint32

const (
	// throwTypeNone means that we are not throwing.
	throwTypeNone throwType = iota

	// throwTypeUser is a throw due to a problem with the application.
	//
	// These throws do not include runtime frames, system goroutines, or
	// frame metadata.
	throwTypeUser

	// throwTypeRuntime is a throw due to a problem with Go itself.
	//
	// These throws include as much information as possible to aid in
	// debugging the runtime, including runtime frames, system goroutines,
	// and frame metadata.
	throwTypeRuntime
)

// We have two different ways of doing defers. The older way involves creating a
// defer record at the time that a defer statement is executing and adding it to a
// defer chain. This chain is inspected by the deferreturn call at all function
// exits in order to run the appropriate defer calls. A cheaper way (which we call
// open-coded defers) is used for functions in which no defer statements occur in
// loops. In that case, we simply store the defer function/arg information into
// specific stack slots at the point of each defer statement, as well as setting a
// bit in a bitmask. At each function exit, we add inline code to directly make
// the appropriate defer calls based on the bitmask and fn/arg information stored
// on the stack. During panic/Goexit processing, the appropriate defer calls are
// made using extra funcdata info that indicates the exact stack slots that
// contain the bitmask and defer fn/args.

// Check to make sure we can really generate a panic. If the panic
// was generated from the runtime, or from inside malloc, then convert
// to a throw of msg.
// pc should be the program counter of the compiler-generated code that
// triggered this panic.
func panicCheck1(pc uintptr, msg string) {
	if goarch.IsWasm == 0 && hasPrefix(funcname(findfunc(pc)), "runtime.") {
		// Note: wasm can't tail call, so we can't get the original caller's pc.
		throw(msg)
	}
	// TODO: is this redundant? How could we be in malloc
	// but not in the runtime? runtime/internal/*, maybe?
	gp := getg()
	if gp != nil && gp.m != nil && gp.m.mallocing != 0 {
		throw(msg)
	}
}

// Same as above, but calling from the runtime is allowed.
//
// Using this function is necessary for any panic that may be
// generated by runtime.sigpanic, since those are always called by the
// runtime.
func panicCheck2(err string) {
	// panic allocates, so to avoid recursive malloc, turn panics
	// during malloc into throws.
	gp := getg()
	if gp != nil && gp.m != nil && gp.m.mallocing != 0 {
		throw(err)
	}
}

// Many of the following panic entry-points turn into throws when they
// happen in various runtime contexts. These should never happen in
// the runtime, and if they do, they indicate a serious issue and
// should not be caught by user code.
//
// The panic{Index,Slice,divide,shift} functions are called by
// code generated by the compiler for out of bounds index expressions,
// out of bounds slice expressions, division by zero, and shift by negative.
// The panicdivide (again), panicoverflow, panicfloat, and panicmem
// functions are called by the signal handler when a signal occurs
// indicating the respective problem.
//
// Since panic{Index,Slice,shift} are never called directly, and
// since the runtime package should never have an out of bounds slice
// or array reference or negative shift, if we see those functions called from the
// runtime package we turn the panic into a throw. That will dump the
// entire runtime stack for easier debugging.
//
// The entry points called by the signal handler will be called from
// runtime.sigpanic, so we can't disallow calls from the runtime to
// these (they always look like they're called from the runtime).
// Hence, for these, we just check for clearly bad runtime conditions.
//
// The panic{Index,Slice} functions are implemented in assembly and tail call
// to the goPanic{Index,Slice} functions below. This is done so we can use
// a space-minimal register calling convention.

// failures in the comparisons for s[x], 0 <= x < y (y == len(s))
//
//go:yeswritebarrierrec
func goPanicIndex(x int, y int) {
	panicCheck1(getcallerpc(), "index out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsIndex})
}

//go:yeswritebarrierrec
func goPanicIndexU(x uint, y int) {
	panicCheck1(getcallerpc(), "index out of range")
	panic(boundsError{x: int64(x), signed: false, y: y, code: boundsIndex})
}

// failures in the comparisons for s[:x], 0 <= x <= y (y == len(s) or cap(s))
//
//go:yeswritebarrierrec
func goPanicSliceAlen(x int, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsSliceAlen})
}

//go:yeswritebarrierrec
func goPanicSliceAlenU(x uint, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: false, y: y, code: boundsSliceAlen})
}

//go:yeswritebarrierrec
func goPanicSliceAcap(x int, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsSliceAcap})
}

//go:yeswritebarrierrec
func goPanicSliceAcapU(x uint, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: false, y: y, code: boundsSliceAcap})
}

// failures in the comparisons for s[x:y], 0 <= x <= y
//
//go:yeswritebarrierrec
func goPanicSliceB(x int, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsSliceB})
}

//go:yeswritebarrierrec
func goPanicSliceBU(x uint, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: false, y: y, code: boundsSliceB})
}

// failures in the comparisons for s[::x], 0 <= x <= y (y == len(s) or cap(s))
func goPanicSlice3Alen(x int, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsSlice3Alen})
}
func goPanicSlice3AlenU(x uint, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3Alen})
}
func goPanicSlice3Acap(x int, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsSlice3Acap})
}
func goPanicSlice3AcapU(x uint, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3Acap})
}

// failures in the comparisons for s[:x:y], 0 <= x <= y
func goPanicSlice3B(x int, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsSlice3B})
}
func goPanicSlice3BU(x uint, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3B})
}

// failures in the comparisons for s[x:y:], 0 <= x <= y
func goPanicSlice3C(x int, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsSlice3C})
}
func goPanicSlice3CU(x uint, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3C})
}

// failures in the conversion ([x]T)(s) or (*[x]T)(s), 0 <= x <= y, y == len(s)
func goPanicSliceConvert(x int, y int) {
	panicCheck1(getcallerpc(), "slice length too short to convert to array or pointer to array")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsConvert})
}

// Implemented in assembly, as they take arguments in registers.
// Declared here to mark them as ABIInternal.
func panicIndex(x int, y int)
func panicIndexU(x uint, y int)
func panicSliceAlen(x int, y int)
func panicSliceAlenU(x uint, y int)
func panicSliceAcap(x int, y int)
func panicSliceAcapU(x uint, y int)
func panicSliceB(x int, y int)
func panicSliceBU(x uint, y int)
func panicSlice3Alen(x int, y int)
func panicSlice3AlenU(x uint, y int)
func panicSlice3Acap(x int, y int)
func panicSlice3AcapU(x uint, y int)
func panicSlice3B(x int, y int)
func panicSlice3BU(x uint, y int)
func panicSlice3C(x int, y int)
func panicSlice3CU(x uint, y int)
func panicSliceConvert(x int, y int)

var shiftError = error(errorString("negative shift amount"))

//go:yeswritebarrierrec
func panicshift() {
	panicCheck1(getcallerpc(), "negative shift amount")
	panic(shiftError)
}

var divideError = error(errorString("integer divide by zero"))

//go:yeswritebarrierrec
func panicdivide() {
	panicCheck2("integer divide by zero")
	panic(divideError)
}

var overflowError = error(errorString("integer overflow"))

func panicoverflow() {
	panicCheck2("integer overflow")
	panic(overflowError)
}

var floatError = error(errorString("floating point error"))

func panicfloat() {
	panicCheck2("floating point error")
	panic(floatError)
}

var memoryError = error(errorString("invalid memory address or nil pointer dereference"))

func panicmem() {
	panicCheck2("invalid memory address or nil pointer dereference")
	panic(memoryError)
}

func panicmemAddr(addr uintptr) {
	panicCheck2("invalid memory address or nil pointer dereference")
	panic(errorAddressString{msg: "invalid memory address or nil pointer dereference", addr: addr})
}

// 创建一个新的延迟函数 fn，该函数没有参数和结果。
// 编译器将 defer 语句转换为对此函数的调用。
func deferproc(fn func()) {
	// 获取当前 goroutine 的 g 结构体。
	gp := getg()

	// 如果当前 goroutine 不是当前正在运行的 goroutine，则抛出异常。
	if gp.m.curg != gp {
		throw("defer on system stack")
	}

	d := newdefer() // 创建一个新的延迟调用记录。

	// 检查新创建的延迟调用记录是否意外地包含了非 nil 的 panic 结构体。
	if d._panic != nil {
		throw("deferproc: d.panic != nil after newdefer")
	}

	d.link = gp._defer   // 将新创建的延迟调用记录链接到当前 goroutine 的延迟调用链表。
	gp._defer = d        // 更新当前 goroutine 的延迟调用链表头。
	d.fn = fn            // 设置延迟调用记录中的函数。
	d.pc = getcallerpc() // 获取调用 deferproc 的函数的程序计数器。

	// 获取调用 deferproc 的函数的栈指针。
	// 必须在调用 getcallersp 和存储结果到 d.sp 之间避免抢占，
	// 因为 getcallersp 的结果是一个 uintptr 类型的栈指针。
	d.sp = getcallersp()

	// 正常情况下是返回0，然后执行defer后面的逻辑，最后在f中执行return时调用deferreturn
	// 异常情况下（panic-recover）返回1，直接执行deferreturn
	return0()
	// 此处不能有代码，因为 C 语言的返回寄存器已经被设置，不能被覆盖
}

// 在栈上排队一个新延迟执行的函数。
// 该函数接收一个已经在栈上分配好的 _defer 结构体作为参数。
// 参数 d 的 fn 字段应该已经被初始化。
// 使用 nosplit 标记是因为栈上的指针字段未初始化。
//
//go:nosplit
func deferprocStack(d *_defer) {
	// 获取当前 goroutine 的状态信息。
	gp := getg()

	// 如果当前 goroutine 不是正在执行的 goroutine，则抛出异常。
	// 这意味着不能在系统栈上进行延迟调用。
	if gp.m.curg != gp {
		throw("defer on system stack")
	}

	// 初始化 _defer 结构体中的一些字段。
	// 注意：fn 字段已经由调用者初始化。
	d.started = false    // 表示延迟调用是否已经开始执行。
	d.heap = false       // 标记该结构体是在栈上分配的。
	d.openDefer = false  // 表示这不是一个开放的延迟调用。
	d.sp = getcallersp() // 获取调用者的栈指针。
	d.pc = getcallerpc() // 获取调用者的程序计数器。
	d.framepc = 0        // 调用者函数的帧地址（对于栈上分配不重要）。
	d.varp = 0           // 变量的地址（对于栈上分配不重要）。

	// 下面的代码使用了 *(*uintptr) 指针来间接修改结构体中的字段。
	// 这是为了避免触发写屏障(write barrier)，因为这些字段都位于栈上，
	// 并且在进入 deferprocStack 时还未经初始化。

	// 初始化 _defer 结构体中的 panic 字段。
	// 由于这是栈上的数据，无需触发写屏障。
	*(*uintptr)(unsafe.Pointer(&d._panic)) = 0

	// 初始化 _defer 结构体中的 fd 字段（用于保存文件描述符等信息）。
	// 由于这是栈上的数据，无需触发写屏障。
	*(*uintptr)(unsafe.Pointer(&d.fd)) = 0

	// 初始化 _defer 结构体中的 link 字段，指向当前 goroutine 的 _defer 链表。
	// 由于这是栈上的数据，无需触发写屏障。
	*(*uintptr)(unsafe.Pointer(&d.link)) = uintptr(unsafe.Pointer(gp._defer))

	// 更新当前 goroutine 的 _defer 链表，将新创建的 _defer 结构体添加进去。
	// 由于我们显式地标记所有 _defer 结构体，因此无需触发写屏障。
	*(*uintptr)(unsafe.Pointer(&gp._defer)) = uintptr(unsafe.Pointer(d))

	// 返回0() 是一个空操作，用于确保 C 语言返回寄存器被设置，防止之后的代码覆盖它。
	// 注意：这里不允许有任何其他代码，因为 C 语言返回寄存器已经被设置，不能被破坏。
	return0()
	// 此处不能有代码，因为 C 语言的返回寄存器已经被设置，不能被覆盖
}

// Each P holds a pool for defers.

// 分配一个 Defer 结构体，通常使用每个 P 的局部缓存池。
// 每个分配的 defer 都必须通过 freedefer 进行释放。此时 defer 并未加入任何 defer 链表中。
func newdefer() *_defer {
	var d *_defer
	mp := acquirem() // 获取一个 m 结构体用于访问 P 结构体。
	pp := mp.p.ptr() // 获取当前 m 结构体关联的 P 结构体。

	// 如果当前 P 的 defer 缓存池为空并且调度器的 defer 缓存池不为空，则从调度器的 defer 缓存池获取 defer。
	if len(pp.deferpool) == 0 && sched.deferpool != nil {
		// 加锁以保护共享 defer 缓存池。
		lock(&sched.deferlock)

		// 当前 P 的 defer 缓存池数量少于其容量的一半时，尝试从调度器的 defer 缓存池中取出 defer。
		for len(pp.deferpool) < cap(pp.deferpool)/2 && sched.deferpool != nil {
			d := sched.deferpool
			sched.deferpool = d.link               // 将调度器 defer 缓存池的头部指向下一个 defer。
			d.link = nil                           // 将取出的 defer 的 link 设为 nil，表示它不再链接到任何链表。
			pp.deferpool = append(pp.deferpool, d) // 将取出的 defer 加入当前 P 的 defer 缓存池。
		}

		// 解锁。
		unlock(&sched.deferlock)
	}

	// 从当前 P 的 defer 缓存池中取出一个 defer。
	if n := len(pp.deferpool); n > 0 {
		d = pp.deferpool[n-1]
		pp.deferpool[n-1] = nil
		// 从 defer 缓存池中移除最后一个 defer。
		pp.deferpool = pp.deferpool[:n-1]
	}

	releasem(mp)      // 释放 m 结构体以便其他 goroutine 可以使用。
	mp, pp = nil, nil // 清除对 m 和 p 的引用以避免内存泄漏。

	// 如果当前 P 的 defer 缓存池为空，则分配一个新的 defer。
	if d == nil {
		// Allocate new defer.
		d = new(_defer)
	}
	// 标记 defer 是从堆中分配的（即使是从缓存池获取的）。
	d.heap = true
	// 返回分配好的 defer。
	return d
}

// 释放给定的延迟调用记录。
// 释放后，该延迟调用记录不可再使用。
//
// 这个函数被标记为 nosplit，因为传入的延迟调用记录处于危险状态。
// 它不在任何延迟调用列表上，因此栈复制不会调整其中的栈指针（例如 d.link）。
// 因此，如果我们复制栈，则 d 可能包含过时的指针。
//
//go:nosplit
func freedefer(d *_defer) {
	// 将延迟调用记录的链接字段设置为 nil，以避免引用循环。
	d.link = nil

	// 从这里开始我们可以复制栈。

	// 释放与该延迟调用相关的 panic 结构体。
	if d._panic != nil {
		freedeferpanic()
	}
	// 释放与该延迟调用相关的函数。
	if d.fn != nil {
		freedeferfn()
	}
	// 如果该延迟调用记录不是分配在堆上的，则直接返回。
	if !d.heap {
		return
	}

	// 获取一个 m 结构体，用于访问 P 结构体。
	mp := acquirem()
	// 获取当前 P 结构体的指针。
	pp := mp.p.ptr()

	// 如果 P 结构体的延迟调用池已满，则将一半的本地缓存转移到中心缓存。
	if len(pp.deferpool) == cap(pp.deferpool) {
		// 将一半的本地缓存转移到中央缓存。
		var first, last *_defer
		for len(pp.deferpool) > cap(pp.deferpool)/2 {
			n := len(pp.deferpool)
			d := pp.deferpool[n-1]
			pp.deferpool[n-1] = nil
			pp.deferpool = pp.deferpool[:n-1]
			if first == nil {
				first = d
			} else {
				last.link = d
			}
			last = d
		}
		// 锁定延迟调用池的互斥锁。
		lock(&sched.deferlock)

		// 将本地缓存的延迟调用记录连接到中心缓存。
		last.link = sched.deferpool
		sched.deferpool = first

		// 解锁延迟调用池的互斥锁。
		unlock(&sched.deferlock)
	}

	// 清空延迟调用记录的内容。
	*d = _defer{}

	// 将延迟调用记录添加回 P 结构体的延迟调用池。
	pp.deferpool = append(pp.deferpool, d)

	// 释放 m 结构体。
	releasem(mp)

	// 释放局部变量，避免内存泄漏。
	mp, pp = nil, nil
}

// Separate function so that it can split stack.
// Windows otherwise runs out of stack space.
func freedeferpanic() {
	// _panic must be cleared before d is unlinked from gp.
	throw("freedefer with d._panic != nil")
}

func freedeferfn() {
	// fn must be cleared before d is unlinked from gp.
	throw("freedefer with d.fn != nil")
}

// 为调用者的帧运行延迟调用的函数。
// 编译器会在任何调用了 defer 的函数末尾插入对该函数的调用。
func deferreturn() {
	// 获取当前 goroutine 的 g 结构体。
	gp := getg()

	// 循环处理延迟调用。
	for {
		// 获取当前 goroutine 的第一个延迟调用记录。
		d := gp._defer
		// 如果延迟调用记录为空，则结束循环。
		if d == nil {
			return
		}

		// 获取调用者函数的栈指针。
		sp := getcallersp()

		// 如果延迟调用记录中的栈指针与当前函数的栈指针不匹配，则说明当前延迟调用记录不属于当前函数，因此结束循环
		if d.sp != sp {
			return
		}

		// 如果延迟调用记录使用了开放编码（即内联编码）。
		if d.openDefer {
			// 执行开放编码的延迟调用。
			done := runOpenDeferFrame(d)
			// 如果没有完成所有开放编码的延迟调用，则抛出异常。
			if !done {
				throw("unfinished open-coded defers in deferreturn")
			}
			// 更新当前 goroutine 的延迟调用记录链表。
			gp._defer = d.link
			// 释放当前延迟调用记录。
			freedefer(d)
			// 如果该帧使用开放编码的延迟调用，则这必须是该帧唯一的延迟调用记录，
			// 因此可以结束循环。
			return
		}

		// 执行延迟调用。
		fn := d.fn         // 获取要执行的函数。
		d.fn = nil         // 清除函数指针，避免重复执行。
		gp._defer = d.link // 更新当前 goroutine 的延迟调用记录链表。使其指向下一个延迟调用记录
		freedefer(d)       // 释放当前延迟调用记录。释放后，该延迟调用记录不可再使用
		fn()               // 执行延迟调用函数。
	}
}

// Goexit terminates the goroutine that calls it. No other goroutine is affected.
// Goexit runs all deferred calls before terminating the goroutine. Because Goexit
// is not a panic, any recover calls in those deferred functions will return nil.
//
// Calling Goexit from the main goroutine terminates that goroutine
// without func main returning. Since func main has not returned,
// the program continues execution of other goroutines.
// If all other goroutines exit, the program crashes.
func Goexit() {
	// Run all deferred functions for the current goroutine.
	// This code is similar to gopanic, see that implementation
	// for detailed comments.
	gp := getg()

	// Create a panic object for Goexit, so we can recognize when it might be
	// bypassed by a recover().
	var p _panic
	p.goexit = true
	p.link = gp._panic
	gp._panic = (*_panic)(noescape(unsafe.Pointer(&p)))

	addOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp()))
	for {
		d := gp._defer
		if d == nil {
			break
		}
		if d.started {
			if d._panic != nil {
				d._panic.aborted = true
				d._panic = nil
			}
			if !d.openDefer {
				d.fn = nil
				gp._defer = d.link
				freedefer(d)
				continue
			}
		}
		d.started = true
		d._panic = (*_panic)(noescape(unsafe.Pointer(&p)))
		if d.openDefer {
			done := runOpenDeferFrame(d)
			if !done {
				// We should always run all defers in the frame,
				// since there is no panic associated with this
				// defer that can be recovered.
				throw("unfinished open-coded defers in Goexit")
			}
			if p.aborted {
				// Since our current defer caused a panic and may
				// have been already freed, just restart scanning
				// for open-coded defers from this frame again.
				addOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp()))
			} else {
				addOneOpenDeferFrame(gp, 0, nil)
			}
		} else {
			// Save the pc/sp in deferCallSave(), so we can "recover" back to this
			// loop if necessary.
			deferCallSave(&p, d.fn)
		}
		if p.aborted {
			// We had a recursive panic in the defer d we started, and
			// then did a recover in a defer that was further down the
			// defer chain than d. In the case of an outstanding Goexit,
			// we force the recover to return back to this loop. d will
			// have already been freed if completed, so just continue
			// immediately to the next defer on the chain.
			p.aborted = false
			continue
		}
		if gp._defer != d {
			throw("bad defer entry in Goexit")
		}
		d._panic = nil
		d.fn = nil
		gp._defer = d.link
		freedefer(d)
		// Note: we ignore recovers here because Goexit isn't a panic
	}
	goexit1()
}

// Call all Error and String methods before freezing the world.
// Used when crashing with panicking.
func preprintpanics(p *_panic) {
	defer func() {
		text := "panic while printing panic value"
		switch r := recover().(type) {
		case nil:
			// nothing to do
		case string:
			throw(text + ": " + r)
		default:
			throw(text + ": type " + toRType(efaceOf(&r)._type).string())
		}
	}()
	for p != nil {
		switch v := p.arg.(type) {
		case error:
			p.arg = v.Error()
		case stringer:
			p.arg = v.String()
		}
		p = p.link
	}
}

// Print all currently active panics. Used when crashing.
// Should only be called after preprintpanics.
func printpanics(p *_panic) {
	if p.link != nil {
		printpanics(p.link)
		if !p.link.goexit {
			print("\t")
		}
	}
	if p.goexit {
		return
	}
	print("panic: ")
	printany(p.arg)
	if p.recovered {
		print(" [recovered]")
	}
	print("\n")
}

// addOneOpenDeferFrame scans the stack (in gentraceback order, from inner frames to
// outer frames) for the first frame (if any) with open-coded defers. If it finds
// one, it adds a single entry to the defer chain for that frame. The entry added
// represents all the defers in the associated open defer frame, and is sorted in
// order with respect to any non-open-coded defers.
//
// addOneOpenDeferFrame stops (possibly without adding a new entry) if it encounters
// an in-progress open defer entry. An in-progress open defer entry means there has
// been a new panic because of a defer in the associated frame. addOneOpenDeferFrame
// does not add an open defer entry past a started entry, because that started entry
// still needs to finished, and addOneOpenDeferFrame will be called when that started
// entry is completed. The defer removal loop in gopanic() similarly stops at an
// in-progress defer entry. Together, addOneOpenDeferFrame and the defer removal loop
// ensure the invariant that there is no open defer entry further up the stack than
// an in-progress defer, and also that the defer removal loop is guaranteed to remove
// all not-in-progress open defer entries from the defer chain.
//
// If sp is non-nil, addOneOpenDeferFrame starts the stack scan from the frame
// specified by sp. If sp is nil, it uses the sp from the current defer record (which
// has just been finished). Hence, it continues the stack scan from the frame of the
// defer that just finished. It skips any frame that already has a (not-in-progress)
// open-coded _defer record in the defer chain.
//
// Note: All entries of the defer chain (including this new open-coded entry) have
// their pointers (including sp) adjusted properly if the stack moves while
// running deferred functions. Also, it is safe to pass in the sp arg (which is
// the direct result of calling getcallersp()), because all pointer variables
// (including arguments) are adjusted as needed during stack copies.
func addOneOpenDeferFrame(gp *g, pc uintptr, sp unsafe.Pointer) {
	var prevDefer *_defer
	if sp == nil {
		prevDefer = gp._defer
		pc = prevDefer.framepc
		sp = unsafe.Pointer(prevDefer.sp)
	}
	systemstack(func() {
		var u unwinder
	frames:
		for u.initAt(pc, uintptr(sp), 0, gp, 0); u.valid(); u.next() {
			frame := &u.frame
			if prevDefer != nil && prevDefer.sp == frame.sp {
				// Skip the frame for the previous defer that
				// we just finished (and was used to set
				// where we restarted the stack scan)
				continue
			}
			f := frame.fn
			fd := funcdata(f, abi.FUNCDATA_OpenCodedDeferInfo)
			if fd == nil {
				continue
			}
			// Insert the open defer record in the
			// chain, in order sorted by sp.
			d := gp._defer
			var prev *_defer
			for d != nil {
				dsp := d.sp
				if frame.sp < dsp {
					break
				}
				if frame.sp == dsp {
					if !d.openDefer {
						throw("duplicated defer entry")
					}
					// Don't add any record past an
					// in-progress defer entry. We don't
					// need it, and more importantly, we
					// want to keep the invariant that
					// there is no open defer entry
					// passed an in-progress entry (see
					// header comment).
					if d.started {
						break frames
					}
					continue frames
				}
				prev = d
				d = d.link
			}
			if frame.fn.deferreturn == 0 {
				throw("missing deferreturn")
			}

			d1 := newdefer()
			d1.openDefer = true
			d1._panic = nil
			// These are the pc/sp to set after we've
			// run a defer in this frame that did a
			// recover. We return to a special
			// deferreturn that runs any remaining
			// defers and then returns from the
			// function.
			d1.pc = frame.fn.entry() + uintptr(frame.fn.deferreturn)
			d1.varp = frame.varp
			d1.fd = fd
			// Save the SP/PC associated with current frame,
			// so we can continue stack trace later if needed.
			d1.framepc = frame.pc
			d1.sp = frame.sp
			d1.link = d
			if prev == nil {
				gp._defer = d1
			} else {
				prev.link = d1
			}
			// Stop stack scanning after adding one open defer record
			break
		}
	})
}

// readvarintUnsafe reads the uint32 in varint format starting at fd, and returns the
// uint32 and a pointer to the byte following the varint.
//
// There is a similar function runtime.readvarint, which takes a slice of bytes,
// rather than an unsafe pointer. These functions are duplicated, because one of
// the two use cases for the functions would get slower if the functions were
// combined.
func readvarintUnsafe(fd unsafe.Pointer) (uint32, unsafe.Pointer) {
	var r uint32
	var shift int
	for {
		b := *(*uint8)((unsafe.Pointer(fd)))
		fd = add(fd, unsafe.Sizeof(b))
		if b < 128 {
			return r + uint32(b)<<shift, fd
		}
		r += ((uint32(b) &^ 128) << shift)
		shift += 7
		if shift > 28 {
			panic("Bad varint")
		}
	}
}

// runOpenDeferFrame 运行指定帧中的活动开放编码(defer)的延迟调用。
// 它通常会处理帧中所有活动的延迟调用，但如果某个延迟调用成功地捕获了一个 panic，则会立即停止。
// 如果帧中没有剩余的延迟调用需要运行，则返回 true。
func runOpenDeferFrame(d *_defer) bool {
	var done = true // 默认情况下认为所有延迟调用都已经处理完毕。
	fd := d.fd      // 获取函数数据指针。

	// 读取延迟调用位图的偏移量以及延迟调用的数量。
	deferBitsOffset, fd := readvarintUnsafe(fd)
	nDefers, fd := readvarintUnsafe(fd)

	// 从 varp 指针减去偏移量得到延迟调用位图。
	deferBits := *(*uint8)(unsafe.Pointer(d.varp - uintptr(deferBitsOffset)))

	// 逆序遍历延迟调用位图，从最高位到最低位。
	for i := int(nDefers) - 1; i >= 0; i-- {
		// 读取当前延迟调用的闭包偏移量。
		var closureOffset uint32
		closureOffset, fd = readvarintUnsafe(fd)

		// 如果当前位为 0，则跳过此延迟调用。
		if deferBits&(1<<i) == 0 {
			continue
		}

		// 获取当前延迟调用的闭包。
		closure := *(*func())(unsafe.Pointer(d.varp - uintptr(closureOffset)))

		// 设置当前延迟调用的函数。
		d.fn = closure

		// 清除已执行的延迟调用位。
		deferBits = deferBits &^ (1 << i)

		// 更新延迟调用位图。
		*(*uint8)(unsafe.Pointer(d.varp - uintptr(deferBitsOffset))) = deferBits

		// 获取当前 panic 结构体。
		p := d._panic

		// 调用延迟调用函数。注意这可能会改变 d.varp 如果栈发生了移动。
		deferCallSave(p, d.fn)

		// 检查是否发生了 panic 被中止的情况。
		if p != nil && p.aborted {
			break
		}

		// 清除延迟调用函数。
		d.fn = nil

		// 如果延迟调用函数成功地捕获了一个 panic，则检查是否还有剩余的延迟调用。
		if d._panic != nil && d._panic.recovered {
			done = deferBits == 0
			break
		}
	}

	return done
}

// deferCallSave calls fn() after saving the caller's pc and sp in the
// panic record. This allows the runtime to return to the Goexit defer
// processing loop, in the unusual case where the Goexit may be
// bypassed by a successful recover.
//
// This is marked as a wrapper by the compiler so it doesn't appear in
// tracebacks.
func deferCallSave(p *_panic, fn func()) {
	if p != nil {
		p.argp = unsafe.Pointer(getargp())
		p.pc = getcallerpc()
		p.sp = unsafe.Pointer(getcallersp())
	}
	fn()
	if p != nil {
		p.pc = 0
		p.sp = unsafe.Pointer(nil)
	}
}

// A PanicNilError happens when code calls panic(nil).
//
// Before Go 1.21, programs that called panic(nil) observed recover returning nil.
// Starting in Go 1.21, programs that call panic(nil) observe recover returning a *PanicNilError.
// Programs can change back to the old behavior by setting GODEBUG=panicnil=1.
type PanicNilError struct {
	// This field makes PanicNilError structurally different from
	// any other struct in this package, and the _ makes it different
	// from any struct in other packages too.
	// This avoids any accidental conversions being possible
	// between this struct and some other struct sharing the same fields,
	// like happened in go.dev/issue/56603.
	_ [0]*PanicNilError
}

func (*PanicNilError) Error() string { return "panic called with nil argument" }
func (*PanicNilError) RuntimeError() {}

var panicnil = &godebugInc{name: "panicnil"}

// 函数实现了预声明的 panic 函数。
// 当一个 goroutine 中发生 panic 时，这个函数会被调用。
func gopanic(e any) {
	// 如果 panic 的原因 e 为 nil，则根据调试标志决定是否使用默认 PanicNilError。
	if e == nil {
		if debug.panicnil.Load() != 1 {
			e = new(PanicNilError)
		} else {
			// 如果设置了不使用默认 PanicNilError，则增加非默认 PanicNilError 的计数。
			panicnil.IncNonDefault()
		}
	}

	// 获取当前 goroutine 的状态信息。
	gp := getg()

	// 如果当前 goroutine 不是当前正在执行的 goroutine，则打印 panic 信息并抛出异常。
	// 这意味着 panic 发生在系统栈上。
	if gp.m.curg != gp {
		print("panic: ")
		printany(e)
		print("\n")
		throw("panic on system stack")
	}

	// 如果当前 goroutine 正在执行内存分配，则打印 panic 信息并抛出异常。
	if gp.m.mallocing != 0 {
		print("panic: ")
		printany(e)
		print("\n")
		throw("panic during malloc")
	}

	// 如果当前 goroutine 的抢占被禁用，则打印 panic 信息和禁用原因，并抛出异常。
	if gp.m.preemptoff != "" {
		print("panic: ")
		printany(e)
		print("\n")
		print("preempt off reason: ")
		print(gp.m.preemptoff)
		print("\n")
		throw("panic during preemptoff")
	}

	// 如果当前 goroutine 持有锁，则打印 panic 信息并抛出异常。
	if gp.m.locks != 0 {
		print("panic: ")
		printany(e)
		print("\n")
		throw("panic holding locks")
	}

	var p _panic                                        // 创建一个新的 _panic 结构体。
	p.arg = e                                           // e 通常是导致 panic 的错误或异常的值
	p.link = gp._panic                                  // 代表当前 goroutine 中发生的最新的 panic
	gp._panic = (*_panic)(noescape(unsafe.Pointer(&p))) //  p 的地址在后续操作中不会被垃圾回收器释放

	// 增加当前正在运行的 panic 的 defer 数量计数。
	runningPanicDefers.Add(1)

	// 计算当前 goroutine 的调用者 PC 和 SP，避免扫描 gopanic 函数的栈帧。
	addOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp()))

	for {
		// 依次查询当前的defer链表
		d := gp._defer
		if d == nil {
			break
		}

		// 如果 defer 已经开始执行（由之前的 panic 或 Goexit 触发），则从列表中移除。
		if d.started {
			if d._panic != nil {
				// 如果 defer 与一个 panic 相关联，则将 panic 的 aborted(是否终止) 字段设置为 true。
				d._panic.aborted = true
			}
			// 清除 defer 与 panic 的关联。
			d._panic = nil
			if !d.openDefer {
				// 对于非开放编码(defer)的 defer，需要从列表中移除。
				// 清除 defer 的 fn 字段。
				d.fn = nil
				// 更新当前 goroutine 的 _defer 指针，将其设置为 d.link，从而从列表中移除 d。
				gp._defer = d.link
				// 释放 defer 占用的资源。
				freedefer(d)
				continue
			}
		}

		// 标记 defer 为已开始执行，但仍保留在列表中，以便在执行 d.fn 之前可以找到并更新 defer 的参数帧。
		d.started = true

		// 记录正在运行 defer 的 panic。
		d._panic = (*_panic)(noescape(unsafe.Pointer(&p)))

		// 标志表示 defer 是否已完成执行。
		done := true

		if d.openDefer {
			// 如果 defer 是开放编码(defer)的，则调用 runOpenDeferFrame 函数来执行 defer。
			done = runOpenDeferFrame(d)
			if done && !d._panic.recovered {
				// 如果 defer 已完成执行且没有被 recover 捕获，则需要添加一个新的空的开放编码(defer)帧。
				addOneOpenDeferFrame(gp, 0, nil)
			}
		} else {
			// 如果 defer 不是开放编码(defer)的，则直接调用 defer 的 fn 字段所指向的函数。
			p.argp = unsafe.Pointer(getargp())
			d.fn() // 真正调用defer定义的函数
		}
		p.argp = nil

		// 如果延迟函数没有引发 panic，则移除 defer。
		if gp._defer != d {
			// 如果 gp._defer 不等于 d，则表示 defer 的状态与预期不符。
			throw("bad defer entry in panic")
		}
		// 清除 defer 与 panic 的关联。
		d._panic = nil

		// 触发栈收缩以测试栈复制。参见 stack_test.go:TestStackPanic
		// GC()

		pc := d.pc                 // 保存 defer 的 PC 和 SP 值。
		sp := unsafe.Pointer(d.sp) // 必须是指针类型，以便在栈复制期间进行调整。

		// 如果 defer 已完成执行，则执行以下操作：
		if done {
			// 清除 defer 的 fn 字段。
			d.fn = nil
			// 更新当前 goroutine 的 _defer 指针，将其设置为 d.link，从而从列表中移除 d。
			gp._defer = d.link
			// 释放 defer 占用的资源。
			freedefer(d)
		}

		// 如果 panic 被 recover 捕获，则更新 gp._panic。
		if p.recovered {
			gp._panic = p.link

			// 如果下一个 panic 是 goexit 类型且已被中止，则需要特殊处理。
			if gp._panic != nil && gp._panic.goexit && gp._panic.aborted {
				// 一个正常的 recover 会绕过/中止 Goexit。相反，
				// 我们返回到 Goexit 的处理循环。
				gp.sigcode0 = uintptr(gp._panic.sp)
				gp.sigcode1 = uintptr(gp._panic.pc)
				mcall(recovery)
				throw("bypassed recovery failed") // mcall 应该不会返回
			}

			// 减少正在运行的 panic 的 defer 数量计数。
			runningPanicDefers.Add(-1)

			// 在 recover 之后，移除任何剩余的未开始执行的、开放编码(defer)的 defer 条目。
			d := gp._defer
			var prev *_defer
			if !done {
				// 跳过当前帧（如果没有完成），它是完成 deferreturn() 中剩余 defer 所需的。
				prev = d
				d = d.link
			}
			for d != nil {
				if d.started {
					// 这个 defer 已经开始执行，但我们正处于 defer-panic-recover 的中间过程，
					// 因此不要移除它或任何进一步的 defer 条目。
					break
				}
				if d.openDefer {
					// 如果 prev 为 nil，则表示 d 是列表的第一个元素。
					if prev == nil {
						gp._defer = d.link
					} else {
						// 如果 prev 不为 nil，则表示 d 不是列表的第一个元素。
						prev.link = d.link
					}
					// 释放 defer 占用的资源。
					newd := d.link
					freedefer(d)
					// 更新 d 为下一个 defer。
					d = newd
				} else {
					// 更新 prev 为 d，即当前 defer。
					prev = d
					// 更新 d 为下一个 defer。
					d = d.link
				}
			}

			gp._panic = p.link
			// 已被标记为中止的 panic 仍然保留在 g.panic 列表中。
			// 从列表中移除它们。
			for gp._panic != nil && gp._panic.aborted {
				gp._panic = gp._panic.link
			}
			if gp._panic == nil { // 必须通过信号完成
				gp.sig = 0
			}
			// 传递有关恢复帧的信息给 recovery。
			gp.sigcode0 = uintptr(sp)
			gp.sigcode1 = pc
			mcall(recovery)          // 调用 recover 后，撤销栈并安排继续执行
			throw("recovery failed") // mcall 应该不会返回
		}
	}

	// 没有剩余的 defer 调用 - 现在进行旧式的 panic 处理。
	// 为了避免在冻结世界后调用任意用户代码的不安全性，我们在 startpanic 之前调用 preprintpanics，
	// 以便调用所有必要的 Error 和 String 方法来准备 panic 字符串。
	preprintpanics(gp._panic)

	fatalpanic(gp._panic) // 应该不会返回
	*(*int)(nil) = 0      // 不应达到此处
}

// getargp returns the location where the caller
// writes outgoing function call arguments.
//
//go:nosplit
//go:noinline
func getargp() uintptr {
	return getcallersp() + sys.MinFrameSize
}

// 实现预声明的 recover 函数。
// 由于需要可靠地找到调用者的栈段，因此不能分割栈。
//
// TODO(rsc): 一旦我们承诺始终使用 CopyStackAlways，
// 这个函数就不需要 nosplit 属性了。
//
//go:nosplit
func gorecover(argp uintptr) any {
	// 必须在 panic 期间作为 defer 调用的一部分运行的函数中调用。
	// 必须从最顶层的函数调用（即 defer 语句中使用的函数）中调用。
	// p.argp 是最顶层的 defer 函数调用的参数指针。
	// 与调用者报告的 argp 进行比较。
	// 如果匹配，那么调用者就是可以进行 recover 的一方。
	// 调用 getg() 获取当前 goroutine (gp)
	gp := getg()
	// 当前 goroutine 的 _panic 结构体
	p := gp._panic
	// 检查是否正在进行 goexit (!p.goexit)。
	// 检查是否已经被 recover 捕获 (!p.recovered)
	// 检查 argp 是否与 _panic 结构体中的 argp 匹配
	if p != nil && !p.goexit && !p.recovered && argp == uintptr(p.argp) {
		// 如果以上条件都满足，则将 p.recovered 设置为 true，表示 panic 已被捕获
		p.recovered = true
		// 返回 panic 时传递的值。
		return p.arg
	}
	return nil
}

//go:linkname sync_throw sync.throw
func sync_throw(s string) {
	throw(s)
}

//go:linkname sync_fatal sync.fatal
func sync_fatal(s string) {
	fatal(s)
}

// throw triggers a fatal error that dumps a stack trace and exits.
//
// throw should be used for runtime-internal fatal errors where Go itself,
// rather than user code, may be at fault for the failure.
//
//go:nosplit
func throw(s string) {
	// Everything throw does should be recursively nosplit so it
	// can be called even when it's unsafe to grow the stack.
	systemstack(func() {
		print("fatal error: ", s, "\n")
	})

	fatalthrow(throwTypeRuntime)
}

// fatal triggers a fatal error that dumps a stack trace and exits.
//
// fatal is equivalent to throw, but is used when user code is expected to be
// at fault for the failure, such as racing map writes.
//
// fatal does not include runtime frames, system goroutines, or frame metadata
// (fp, sp, pc) in the stack trace unless GOTRACEBACK=system or higher.
//
//go:nosplit
func fatal(s string) {
	// Everything fatal does should be recursively nosplit so it
	// can be called even when it's unsafe to grow the stack.
	systemstack(func() {
		print("fatal error: ", s, "\n")
	})

	fatalthrow(throwTypeUser)
}

// runningPanicDefers is non-zero while running deferred functions for panic.
// This is used to try hard to get a panic stack trace out when exiting.
var runningPanicDefers atomic.Uint32

// panicking is non-zero when crashing the program for an unrecovered panic.
var panicking atomic.Uint32

// paniclk is held while printing the panic information and stack trace,
// so that two concurrent panics don't overlap their output.
var paniclk mutex

// 在一个 defer 函数调用 recover 后，撤销栈并安排继续执行，就好像 defer 函数的调用者正常返回一样。
func recovery(gp *g) {
	// 有关在 G 结构中传递的 defer 的信息。
	sp := gp.sigcode0
	pc := gp.sigcode1

	// d 的参数需要在栈中。
	if sp != 0 && (sp < gp.stack.lo || gp.stack.hi < sp) {
		// 如果栈指针不在 goroutine 的栈范围内，则打印错误信息并抛出异常。
		print("recover: ", hex(sp), " not in [", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n")
		throw("bad recovery")
	}

	// 使 deferproc 对于这个 d 再次返回，
	// 这次返回 1。调用函数将会跳转到标准返回尾声。
	gp.sched.sp = sp
	gp.sched.pc = pc
	gp.sched.lr = 0
	// 恢复支持帧指针的平台上的 bp。
	// 注意：对于不支持帧指针的平台，不设置任何值也是可以的，因为没有东西会消费它们。
	switch {
	case goarch.IsAmd64 != 0:
		// 在 x86 架构中，架构 bp 存储在栈指针下方两个字的位置。
		gp.sched.bp = *(*uintptr)(unsafe.Pointer(sp - 2*goarch.PtrSize))
	case goarch.IsArm64 != 0:
		// 在 arm64 架构中，架构 bp 指向比 sp 高一个字的位置。
		gp.sched.bp = sp - goarch.PtrSize
	}

	// 设置返回值，表示 defer 函数正常返回。
	gp.sched.ret = 1
	gogo(&gp.sched) // defer恢复执行。
}

// fatalthrow implements an unrecoverable runtime throw. It freezes the
// system, prints stack traces starting from its caller, and terminates the
// process.
//
//go:nosplit
func fatalthrow(t throwType) {
	pc := getcallerpc()
	sp := getcallersp()
	gp := getg()

	if gp.m.throwing == throwTypeNone {
		gp.m.throwing = t
	}

	// Switch to the system stack to avoid any stack growth, which may make
	// things worse if the runtime is in a bad state.
	systemstack(func() {
		if isSecureMode() {
			exit(2)
		}

		startpanic_m()

		if dopanic_m(gp, pc, sp) {
			// crash uses a decent amount of nosplit stack and we're already
			// low on stack in throw, so crash on the system stack (unlike
			// fatalpanic).
			crash()
		}

		exit(2)
	})

	*(*int)(nil) = 0 // not reached
}

// fatalpanic implements an unrecoverable panic. It is like fatalthrow, except
// that if msgs != nil, fatalpanic also prints panic messages and decrements
// runningPanicDefers once main is blocked from exiting.
//
//go:nosplit
func fatalpanic(msgs *_panic) {
	pc := getcallerpc()
	sp := getcallersp()
	gp := getg()
	var docrash bool
	// Switch to the system stack to avoid any stack growth, which
	// may make things worse if the runtime is in a bad state.
	systemstack(func() {
		if startpanic_m() && msgs != nil {
			// There were panic messages and startpanic_m
			// says it's okay to try to print them.

			// startpanic_m set panicking, which will
			// block main from exiting, so now OK to
			// decrement runningPanicDefers.
			runningPanicDefers.Add(-1)

			printpanics(msgs)
		}

		docrash = dopanic_m(gp, pc, sp)
	})

	if docrash {
		// By crashing outside the above systemstack call, debuggers
		// will not be confused when generating a backtrace.
		// Function crash is marked nosplit to avoid stack growth.
		crash()
	}

	systemstack(func() {
		exit(2)
	})

	*(*int)(nil) = 0 // not reached
}

// startpanic_m prepares for an unrecoverable panic.
//
// It returns true if panic messages should be printed, or false if
// the runtime is in bad shape and should just print stacks.
//
// It must not have write barriers even though the write barrier
// explicitly ignores writes once dying > 0. Write barriers still
// assume that g.m.p != nil, and this function may not have P
// in some contexts (e.g. a panic in a signal handler for a signal
// sent to an M with no P).
//
//go:nowritebarrierrec
func startpanic_m() bool {
	gp := getg()
	if mheap_.cachealloc.size == 0 { // very early
		print("runtime: panic before malloc heap initialized\n")
	}
	// Disallow malloc during an unrecoverable panic. A panic
	// could happen in a signal handler, or in a throw, or inside
	// malloc itself. We want to catch if an allocation ever does
	// happen (even if we're not in one of these situations).
	gp.m.mallocing++

	// If we're dying because of a bad lock count, set it to a
	// good lock count so we don't recursively panic below.
	if gp.m.locks < 0 {
		gp.m.locks = 1
	}

	switch gp.m.dying {
	case 0:
		// Setting dying >0 has the side-effect of disabling this G's writebuf.
		gp.m.dying = 1
		panicking.Add(1)
		lock(&paniclk)
		if debug.schedtrace > 0 || debug.scheddetail > 0 {
			schedtrace(true)
		}
		freezetheworld()
		return true
	case 1:
		// Something failed while panicking.
		// Just print a stack trace and exit.
		gp.m.dying = 2
		print("panic during panic\n")
		return false
	case 2:
		// This is a genuine bug in the runtime, we couldn't even
		// print the stack trace successfully.
		gp.m.dying = 3
		print("stack trace unavailable\n")
		exit(4)
		fallthrough
	default:
		// Can't even print! Just exit.
		exit(5)
		return false // Need to return something.
	}
}

var didothers bool
var deadlock mutex

// gp is the crashing g running on this M, but may be a user G, while getg() is
// always g0.
func dopanic_m(gp *g, pc, sp uintptr) bool {
	if gp.sig != 0 {
		signame := signame(gp.sig)
		if signame != "" {
			print("[signal ", signame)
		} else {
			print("[signal ", hex(gp.sig))
		}
		print(" code=", hex(gp.sigcode0), " addr=", hex(gp.sigcode1), " pc=", hex(gp.sigpc), "]\n")
	}

	level, all, docrash := gotraceback()
	if level > 0 {
		if gp != gp.m.curg {
			all = true
		}
		if gp != gp.m.g0 {
			print("\n")
			goroutineheader(gp)
			traceback(pc, sp, 0, gp)
		} else if level >= 2 || gp.m.throwing >= throwTypeRuntime {
			print("\nruntime stack:\n")
			traceback(pc, sp, 0, gp)
		}
		if !didothers && all {
			didothers = true
			tracebackothers(gp)
		}
	}
	unlock(&paniclk)

	if panicking.Add(-1) != 0 {
		// Some other m is panicking too.
		// Let it print what it needs to print.
		// Wait forever without chewing up cpu.
		// It will exit when it's done.
		lock(&deadlock)
		lock(&deadlock)
	}

	printDebugLog()

	return docrash
}

// canpanic returns false if a signal should throw instead of
// panicking.
//
//go:nosplit
func canpanic() bool {
	gp := getg()
	mp := acquirem()

	// Is it okay for gp to panic instead of crashing the program?
	// Yes, as long as it is running Go code, not runtime code,
	// and not stuck in a system call.
	if gp != mp.curg {
		releasem(mp)
		return false
	}
	// N.B. mp.locks != 1 instead of 0 to account for acquirem.
	if mp.locks != 1 || mp.mallocing != 0 || mp.throwing != throwTypeNone || mp.preemptoff != "" || mp.dying != 0 {
		releasem(mp)
		return false
	}
	status := readgstatus(gp)
	if status&^_Gscan != _Grunning || gp.syscallsp != 0 {
		releasem(mp)
		return false
	}
	if GOOS == "windows" && mp.libcallsp != 0 {
		releasem(mp)
		return false
	}
	releasem(mp)
	return true
}

// shouldPushSigpanic reports whether pc should be used as sigpanic's
// return PC (pushing a frame for the call). Otherwise, it should be
// left alone so that LR is used as sigpanic's return PC, effectively
// replacing the top-most frame with sigpanic. This is used by
// preparePanic.
func shouldPushSigpanic(gp *g, pc, lr uintptr) bool {
	if pc == 0 {
		// Probably a call to a nil func. The old LR is more
		// useful in the stack trace. Not pushing the frame
		// will make the trace look like a call to sigpanic
		// instead. (Otherwise the trace will end at sigpanic
		// and we won't get to see who faulted.)
		return false
	}
	// If we don't recognize the PC as code, but we do recognize
	// the link register as code, then this assumes the panic was
	// caused by a call to non-code. In this case, we want to
	// ignore this call to make unwinding show the context.
	//
	// If we running C code, we're not going to recognize pc as a
	// Go function, so just assume it's good. Otherwise, traceback
	// may try to read a stale LR that looks like a Go code
	// pointer and wander into the woods.
	if gp.m.incgo || findfunc(pc).valid() {
		// This wasn't a bad call, so use PC as sigpanic's
		// return PC.
		return true
	}
	if findfunc(lr).valid() {
		// This was a bad call, but the LR is good, so use the
		// LR as sigpanic's return PC.
		return false
	}
	// Neither the PC or LR is good. Hopefully pushing a frame
	// will work.
	return true
}

// isAbortPC reports whether pc is the program counter at which
// runtime.abort raises a signal.
//
// It is nosplit because it's part of the isgoexception
// implementation.
//
//go:nosplit
func isAbortPC(pc uintptr) bool {
	f := findfunc(pc)
	if !f.valid() {
		return false
	}
	return f.funcID == abi.FuncID_abort
}
